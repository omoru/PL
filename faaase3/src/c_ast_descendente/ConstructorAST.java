/* Generated By:JavaCC: Do not edit this line. ConstructorAST.java */
package c_ast_descendente;

import asint.TinyASint.Dec;
import asint.TinyASint.Exp;
import asint.TinyASint.Inst;
import asint.TinyASint.LDecs;
import asint.TinyASint.LInst;
import asint.TinyASint.Prog;
import asint.TinyASint.StringLocalizado;
import asint.TinyASint.Tipo;
import semops.SemOps;


public class ConstructorAST implements ConstructorASTConstants {
   private SemOps sem = new SemOps();

  final public Prog Init() throws ParseException {
                       Prog prog;
    prog = PROGRAMA();
    jj_consume_token(0);
                       {if (true) return prog;}
    throw new Error("Missing return statement in function");
  }

  final public Prog PROGRAMA() throws ParseException {
                       LDecs ldecs; LInst linst;
    ldecs = LDECS();
    linst = LINST();
                       {if (true) return sem.programa(ldecs,linst);}
    throw new Error("Missing return statement in function");
  }

  final public LDecs LDECS() throws ParseException {
                       Dec dec; LDecs decs,result;
    dec = DEC();
    result = RDECS(sem.decs_una(dec));
                       {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public LDecs RDECS(LDecs res_h) throws ParseException {
                                 Dec dec; LDecs rdecs;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 46:
      jj_consume_token(46);
      dec = DEC();
      rdecs = RDECS(sem.decs_muchas(res_h,dec));
                      {if (true) return rdecs;}
      break;
    default:
      jj_la1[0] = jj_gen;
                        {if (true) return res_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec DEC() throws ParseException {
                    Token id;Tipo tipo;Dec res;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case var:
      jj_consume_token(var);
      tipo = TIPO();
      id = jj_consume_token(identificador);
                                                              {if (true) return sem.dec_var(tipo,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case type:
      jj_consume_token(type);
      tipo = TIPO();
      id = jj_consume_token(identificador);
                                                               {if (true) return sem.dec_type(tipo,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case proc:
      jj_consume_token(proc);
      id = jj_consume_token(identificador);
      jj_consume_token(47);
      res = RES_DEC(sem.str(id.image,id.beginLine,id.beginColumn));
                                                                                                                  {if (true) return res;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec RES_DEC(Token id_h) throws ParseException {
                             LParams lparams; Bloque bloque;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case r_int:
    case r_real:
    case r_bool:
    case r_string:
    case array:
    case record:
    case pointer:
    case identificador:
      lparams = LPARAMS();
      jj_consume_token(48);
      bloque = BLOQUE();
                                                                     {if (true) return sem.dec_proc_con_params(sem.str(id_h.image,id_h.beginLine,id_h.beginColumn),lparams,bloque);}
      break;
    case 48:
      jj_consume_token(48);
      bloque = BLOQUE();
                                                   {if (true) return sem.dec_proc_sin_params(sem.str(id_h.image,id_h.beginLine,id_h.beginColumn),bloque);}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LParams LPARAMS() throws ParseException {
                        Param param; LParams rlparams;
    param = PARAM();
    rlparams = RLPARAMS(sem.l_params_uno(param));
                      {if (true) return rlparams;}
    throw new Error("Missing return statement in function");
  }

  final public LParams RLPARAMS(LParam param_h) throws ParseException {
                                      Param param; LParams rlparams;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 49:
      jj_consume_token(49);
      param = PARAM();
                                                       {if (true) return RLPARAMS(sem.l_params_muchos(param_h,param));}
      break;
    default:
      jj_la1[3] = jj_gen;
                                     {if (true) return param_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Param PARAM() throws ParseException {
                      Tipo tipo;
    tipo = TIPO();
                                    {if (true) return RPARAM(tipo);}
    throw new Error("Missing return statement in function");
  }

  final public Param RPARAM(Tipo tipo_h) throws ParseException {
                                 Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case identificador:
      id = jj_consume_token(identificador);
                                                        {if (true) return sem.param_sin_amp(tipo_h,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case 50:
      jj_consume_token(50);
      id = jj_consume_token(identificador);
                                                           {if (true) return sem.param_con_amp(tipo_h,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Tipo TIPO() throws ParseException {
                 Token id,num; Tipo tipo; LCampos lcampos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case r_int:
      jj_consume_token(r_int);
                               {if (true) return sem.tipo_Entero();}
      break;
    case r_real:
      jj_consume_token(r_real);
                                {if (true) return sem.tipo_Real();}
      break;
    case r_bool:
      jj_consume_token(r_bool);
                                {if (true) return sem.tipo_Bool();}
      break;
    case r_string:
      jj_consume_token(r_string);
                                  {if (true) return sem.tipo_String();}
      break;
    case identificador:
      id = jj_consume_token(identificador);
                                            {if (true) return sem.tipo_Id(sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case array:
      jj_consume_token(array);
      jj_consume_token(51);
      num = jj_consume_token(numeroEntero);
      jj_consume_token(52);
      jj_consume_token(of);
      tipo = TIPO();
                                                                               {if (true) return sem.tipo_Array(sem.str(num.image,num.beginLine,num.beginColumn),tipo);}
      break;
    case record:
      jj_consume_token(record);
      jj_consume_token(53);
      lcampos = CAMPOS();
      jj_consume_token(54);
                                                           {if (true) return sem.tipo_Reg(lcampos);}
      break;
    case pointer:
      jj_consume_token(pointer);
      tipo = TIPO();
                                               {if (true) return sem.tipo_Pointer(tipo);}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LCampos CAMPOS() throws ParseException {
                       Campo campo; LCampos rcampos;
    campo = CAMPO();
    rcampos = RCAMPOS(sem.l_campos_uno(campo));
                                                                                   {if (true) return rcampos;}
    throw new Error("Missing return statement in function");
  }

  final public LCampos RCAMPOS(LCampos res_h) throws ParseException {
                                     Campo campo; LCampos rcampos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 46:
      jj_consume_token(46);
      campo = CAMPO();
      rcampos = RCAMPOS(sem.l_campos_muchos(res_h,campo));
                                                                                                            {if (true) return rcampos;}
      break;
    default:
      jj_la1[6] = jj_gen;
                                     {if (true) return res_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Campo CAMPO() throws ParseException {
                    Tipo tipo; Token id;
    tipo = TIPO();
    id = jj_consume_token(identificador);
                                                        {if (true) return sem.campo(tipo,sem.str(id.image,id.beginLine,id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public LInst LINST() throws ParseException {
                    Inst inst; LInst rlinst;
    inst = INST();
    rlinst = RLINST(sem.l_inst_una(inst));
               {if (true) return rlinst;}
    throw new Error("Missing return statement in function");
  }

  final public LInst RLINST(LInst res_h) throws ParseException {
                                Inst inst; LInst rlinst;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 46:
      jj_consume_token(46);
      inst = INST();
      rlinst = RLINST(sem.l_inst_muchas(res_h,inst));
                                                                                      {if (true) return rlinst;}
      break;
    default:
      jj_la1[7] = jj_gen;
                       {if (true) return res_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst INST() throws ParseException {
               Exp exp1,exp2; LInst_aux linst_aux; Inst res_if,res_call; Token id; Bloque bloque;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case not:
    case r_true:
    case r_false:
    case r_null:
    case identificador:
    case numeroEntero:
    case numeroReal:
    case str:
    case 47:
    case 57:
    case 58:
      exp1 = E0();
      jj_consume_token(55);
      exp2 = E0();
                                             {if (true) return sem.inst_asig(exp1,exp2);}
      break;
    case r_if:
      jj_consume_token(r_if);
      exp1 = E0();
      jj_consume_token(then);
      linst_aux = AUX_LINST();
      res_if = RES_IF(exp1,linst_aux);
                                                                                                   {if (true) return res_if;}
      break;
    case r_while:
      jj_consume_token(r_while);
      exp1 = E0();
      jj_consume_token(r_do);
      linst_aux = AUX_LINST();
      jj_consume_token(endwhile);
                                                                                   {if (true) return sem.inst_while(exp1,linst_aux);}
      break;
    case read:
      jj_consume_token(read);
      exp1 = E0();
                                     {if (true) return sem.inst_read(exp1);}
      break;
    case write:
      jj_consume_token(write);
      exp1 = E0();
                                      {if (true) return sem.inst_write(exp1);}
      break;
    case nl:
      jj_consume_token(nl);
                       {if (true) return sem.inst_nl;}
      break;
    case r_new:
      jj_consume_token(r_new);
      exp1 = E0();
                                      {if (true) return sem.inst_new(exp1);}
      break;
    case delete:
      jj_consume_token(delete);
      exp1 = E0();
                                       {if (true) return sem.inst_delete(exp1);}
      break;
    case call:
      jj_consume_token(call);
      id = jj_consume_token(identificador);
      jj_consume_token(47);
      res_call = RES_CALL(sem.str(id.image,id.beginLine,id.beginColumn));
                                                                                                                      {if (true) return res_call;}
      break;
    case 53:
      bloque = BLOQUE();
                                     {if (true) return sem.inst_compuesta(bloque);}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst RES_CALL(Token id_h) throws ParseException {
                             Lreal_params r_params;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 48:
      jj_consume_token(48);
                               {if (true) return sem.inst_call_sin_params(sem.str(id_h.image,id_h.beginLine,id_h.beginColumn));}
      break;
    case not:
    case r_true:
    case r_false:
    case r_null:
    case identificador:
    case numeroEntero:
    case numeroReal:
    case str:
    case 47:
    case 57:
    case 58:
      r_params = REAL_PARAMS();
      jj_consume_token(48);
                                                         {if (true) return sem.inst_call_con_params(sem.str(id_h.image,id_h.beginLine,id_h.beginColumn),r_params);}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LInst_aux AUX_LINST() throws ParseException {
                            LInst linst;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case r_if:
    case r_while:
    case read:
    case write:
    case nl:
    case r_new:
    case delete:
    case call:
    case not:
    case r_true:
    case r_false:
    case r_null:
    case identificador:
    case numeroEntero:
    case numeroReal:
    case str:
    case 47:
    case 53:
    case 57:
    case 58:
      linst = LINST();
                                        {if (true) return sem.linst_aux(linst);}
      break;
    default:
      jj_la1[10] = jj_gen;
                         {if (true) return sem.linst_aux_vacia();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst RES_IF(Exp exp_h, LInst_aux linst_aux_h) throws ParseException {
                                                    LInst_aux linst_aux;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case r_else:
      jj_consume_token(r_else);
      linst_aux = AUX_LINST();
      jj_consume_token(endif);
                                                              {if (true) return sem.inst_if_then_else(exp_h,linst_aux_h,linst_aux);}
      break;
    case endif:
      jj_consume_token(endif);
                             {if (true) return sem.inst_if_then(exp1,linst_aux_h);}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Lreal_params REAL_PARAMS() throws ParseException {
                                 Exp exp; Lreal_params res_params;
    exp = E0();
    res_params = RES_PARAMS(sem.l_real_params_uno(exp));
                                                                                       {if (true) return res_params;}
    throw new Error("Missing return statement in function");
  }

  final public Lreal_params RES_PARAMS(Lreal_params params_h) throws ParseException {
                                                     Exp exp; Lreal_params res_params;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 49:
      jj_consume_token(49);
      exp = E0();
      res_params = RES_PARAMS(sem.l_real_params_muchos(params_h,exp));
                                                                                                               {if (true) return res_params;}
      break;
    default:
      jj_la1[12] = jj_gen;
                                  {if (true) return param_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Bloque BLOQUE() throws ParseException {
                      Bloque b;
    jj_consume_token(53);
    b = RBLOQUE();
                                                      {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  final public Bloque RBLOQUE() throws ParseException {
                       Prog prog;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 54:
      jj_consume_token(54);
                             {if (true) return sem.bloque_vacio();}
      break;
    case var:
    case type:
    case proc:
      prog = PROGRAMA();
      jj_consume_token(54);
                                                 {if (true) return sem.bloque(prog);}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E0() throws ParseException {
               Exp e,res;
    e = E1();
    res = RES0(e);
                                                     {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RES0(Exp exp_h) throws ParseException {
                          Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 56:
      jj_consume_token(56);
      e = E0();
                                        {if (true) return sem.exp("+",exp_h,e);}
      break;
    case 57:
      jj_consume_token(57);
      e = E1();
                                          {if (true) return sem.exp("-",exp_h,e);}
      break;
    default:
      jj_la1[14] = jj_gen;
                             {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E1() throws ParseException {
               Exp e,res;
    e = E2();
    res = RES1(e);
                                                     {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RES1(Exp exp_h) throws ParseException {
                          String op; Exp e,res;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and:
    case or:
      op = OP1AI();
      e = E2();
      res = RES1(sem.exp(op,exp_h,e));
                                                                                  {if (true) return res;}
      break;
    default:
      jj_la1[15] = jj_gen;
                              {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E2() throws ParseException {
               Exp e,res;
    e = E3();
    res = RES2(e);
                                                     {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RES2(Exp exp_h) throws ParseException {
                          String op; Exp e,res;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
      op = OP2AI();
      e = E3();
      res = RES2(sem.exp(op,exp_h,e));
                                                                      {if (true) return res;}
      break;
    default:
      jj_la1[16] = jj_gen;
                {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E3() throws ParseException {
               Exp e,res;
    e = E4();
    res = RES3(e);
                                                     {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RES3(Exp exp_h) throws ParseException {
                          String op; Exp e,res;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
    case 65:
    case 66:
      op = OP3NA();
      e = E4();
                                                 {if (true) return sem.exp(op,exp_h,e);}
      break;
    default:
      jj_la1[17] = jj_gen;
                            {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E4() throws ParseException {
               Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
      jj_consume_token(57);
      e = E5();
                                      {if (true) return sem.menos_unario(e);}
      break;
    case not:
      jj_consume_token(not);
      e = E4();
                                         {if (true) return sem.Not(e);}
      break;
    case r_true:
    case r_false:
    case r_null:
    case identificador:
    case numeroEntero:
    case numeroReal:
    case str:
    case 47:
    case 58:
      e = E5();
                                   {if (true) return e;}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E5() throws ParseException {
               Exp e,res;
    e = E6();
    res = RES_RES5(e);
                                                         {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RES_RES5(Exp exp_h) throws ParseException {
                              Exp e,res;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case punto:
    case flecha:
    case 51:
      e = RES5(exp_h);
      res = RES_RES5(e);
                                                           {if (true) return res;}
      break;
    default:
      jj_la1[19] = jj_gen;
                         {if (true) return exp_h;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp RES5(Exp exp_h) throws ParseException {
                          String op; Exp e; Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 51:
      jj_consume_token(51);
      e = E0();
      jj_consume_token(52);
                                               {if (true) return sem.index(exp_h,e);}
      break;
    case punto:
      jj_consume_token(punto);
      id = jj_consume_token(identificador);
                                                          {if (true) return sem.punto(exp_h,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case flecha:
      jj_consume_token(flecha);
      id = jj_consume_token(identificador);
                                                           {if (true) return sem.flecha(exp_h,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E6() throws ParseException {
               Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
      jj_consume_token(58);
      e = E6();
                                      {if (true) return sem.indireccion(e);}
      break;
    case r_true:
    case r_false:
    case r_null:
    case identificador:
    case numeroEntero:
    case numeroReal:
    case str:
    case 47:
      e = E7();
                                   {if (true) return e;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E7() throws ParseException {
               Token t; Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case numeroEntero:
      t = jj_consume_token(numeroEntero);
                                {if (true) return sem.numEnt(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case numeroReal:
      t = jj_consume_token(numeroReal);
                              {if (true) return sem.numReal(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case str:
      t = jj_consume_token(str);
                        {if (true) return sem.str(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case r_true:
      jj_consume_token(r_true);
                      {if (true) return sem.c_rue();}
      break;
    case r_false:
      jj_consume_token(r_false);
                       {if (true) return sem.c_alse();}
      break;
    case identificador:
      t = jj_consume_token(identificador);
                                 {if (true) return sem.str(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case r_null:
      jj_consume_token(r_null);
                      {if (true) return sem.c_null();}
      break;
    case 47:
      jj_consume_token(47);
      e = E0();
      jj_consume_token(48);
                              {if (true) return e;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OP1AI() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case and:
      jj_consume_token(and);
                               {if (true) return "and";}
      break;
    case or:
      jj_consume_token(or);
                                                      {if (true) return or;}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OP2AI() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 59:
      jj_consume_token(59);
                              {if (true) return "!=";}
      break;
    case 60:
      jj_consume_token(60);
                                                    {if (true) return "==";}
      break;
    case 61:
      jj_consume_token(61);
                                                                         {if (true) return "<";}
      break;
    case 62:
      jj_consume_token(62);
                             {if (true) return ">";}
      break;
    case 63:
      jj_consume_token(63);
                                                  {if (true) return "<=";}
      break;
    case 64:
      jj_consume_token(64);
                                                                        {if (true) return ">=";}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OP3NA() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
      jj_consume_token(58);
                             {if (true) return "*";}
      break;
    case 65:
      jj_consume_token(65);
                                                 {if (true) return "/";}
      break;
    case 66:
      jj_consume_token(66);
                                                                     {if (true) return "%";}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public ConstructorASTTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x1c00,0x1be000,0x0,0x0,0x1be000,0x0,0x0,0xf2200000,0x0,0xf2200000,0x1800000,0x0,0x1c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x4000,0x0,0x10400,0x20000,0x40400,0x400,0x4000,0x4000,0x620bc3f,0x601bc3c,0x620bc3f,0x0,0x20000,0x400000,0x3000000,0xc0,0xf8000000,0x4000000,0x600bc3c,0x80300,0x80300,0x400bc38,0xbc38,0xc0,0xf8000000,0x4000000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x6,};
   }

  public ConstructorAST(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstructorASTTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public ConstructorAST(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstructorASTTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public ConstructorAST(ConstructorASTTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(ConstructorASTTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[67];
    for (int i = 0; i < 67; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
